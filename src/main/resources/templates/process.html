<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <title th:text="${processName}"></title>
    <!-- Removed inline styles, using Bootstrap progress bar -->
    <script type="text/javascript">
        let progressTimer = null;
        let processActive = false; // Flag to prevent multiple fetches after completion/cancel

        async function fetchProgress() {
            if (!processActive) return; // Stop fetching if process inactive

            try {
                const response = await fetch('/method/progress', {
                    method: 'POST' // Should this be GET if just fetching status? Adjust if needed.
                });
                if (response.ok) {
                    const data = await response.json();
                    console.debug("ProgressBar response: title=" + data.title + ", step=" + data.step + ", maxStep=" + data.maxstep + ", message=" + data.message);
                    updateProgressBar(data.title, data.step, data.maxstep, data.message);
                } else {
                    console.error('Failed to fetch progress. Status:', response.status);
                    // Optional: Stop polling on failure?
                    // stopProgressPolling();
                    // updateProgressBar("Error", 0, 1, "Failed to fetch progress.");
                }
            } catch (error) {
                console.error('Error fetching progress:', error);
                // Optional: Stop polling on error?
                // stopProgressPolling();
                // updateProgressBar("Error", 0, 1, "Error fetching progress.");
            }
        }

        function updateProgressBar(title, step, maxStep, message) {
            let progressBar = document.getElementById('progress-bar');
            let progress = 0;
            // Ensure maxStep is valid and > 0 to avoid division by zero
            if (maxStep && maxStep > 0) {
                // Clamp step between 0 and maxStep
                const clampedStep = Math.max(0, Math.min(step, maxStep));
                progress = (clampedStep / maxStep) * 100;
            } else if (step > 0) {
                // Handle indeterminate case or maxStep=0 scenario
                progress = 100; // Or some other indicator
                console.warn("MaxStep is invalid or zero. Setting progress based on step.");
            }


            progressBar.style.width = progress + '%';
            progressBar.setAttribute('aria-valuenow', progress.toFixed(0));
            progressBar.textContent = progress.toFixed(0) + '%';

            // Update title and message
            document.getElementById('progress-title').innerText = title || document.getElementById('progress-title').innerText; // Keep old title if new one is empty
            document.getElementById('message-block').innerText = message;

            if (progress >= 100 || step >= maxStep) {
                progressBar.classList.remove('progress-bar-animated', 'progress-bar-striped');
                progressBar.classList.add('bg-success'); // Indicate completion
                stopProgressPolling();
                document.getElementById('cancel-button').style.display = 'none';
                document.getElementById('back-button').style.display = 'inline-block'; // Use inline-block for buttons
            } else {
                progressBar.classList.add('progress-bar-animated', 'progress-bar-striped');
                progressBar.classList.remove('bg-success');
                document.getElementById('cancel-button').style.display = 'inline-block';
                document.getElementById('back-button').style.display = 'none';
            }
        }

        function stopProgressPolling() {
            processActive = false;
            if (progressTimer) {
                clearInterval(progressTimer);
                progressTimer = null;
                console.debug("Stopped progress polling.");
            }
        }


        function startProcess() {
            // Ensure buttons are in the correct initial state
            document.getElementById('cancel-button').style.display = 'inline-block';
            document.getElementById('back-button').style.display = 'none';
            document.getElementById('message-block').innerText = 'Starting process...'; // Initial message
            processActive = true;

            try {
                // Use await to ensure the process endpoint is hit before starting polling
                const response = fetch('[[${processFunction}]]', {
                    method: 'POST'
                });
                console.debug("Started process, beginning polling.");
                fetchProgress();
                progressTimer = setInterval(fetchProgress, 1000); // Poll every 1 second (adjust as needed)

            } catch (error) {
                console.error('Error starting process:', error);
                document.getElementById('message-block').innerText = "An error occurred while trying to start the process.";
                stopProgressPolling();
                document.getElementById('cancel-button').style.display = 'none';
                document.getElementById('back-button').style.display = 'inline-block';
            }
        }

        function cancelProcess() {
            console.debug("Attempting to cancel process...");
            stopProgressPolling(); // Stop polling immediately

            try {
                const response = fetch("/method/cancel", {
                    method: "POST"
                });
                console.log("Cancel request sent successfully.");
                document.getElementById('message-block').innerText = "Process cancellation requested.";
            } catch (error) {
                console.error("Error sending cancel request:", error);
                document.getElementById('message-block').innerText = "Error occurred while sending cancel request.";
            } finally {
                // Always show Return button after attempting cancel
                document.getElementById('cancel-button').style.display = 'none';
                document.getElementById('back-button').style.display = 'inline-block';
                // Optional: Update progress bar to show cancellation visually
                let progressBar = document.getElementById('progress-bar');
                progressBar.classList.remove('progress-bar-animated', 'progress-bar-striped');
                progressBar.classList.add('bg-warning'); // Indicate cancellation/warning
                progressBar.textContent = 'Cancelled';
            }
        }

        window.onload = startProcess;
    </script>
</head>

<body>
    <div class="container mt-4">
        <div th:insert="~{templates :: logging}"></div>

        <h1 th:text="${processName}"></h1>
        <h2 id="progress-title" class="h4 text-muted">Initializing...</h2>

        <div class="progress mt-3 mb-3" role="progressbar" aria-label="Process progress" aria-valuenow="0"
            aria-valuemin="0" aria-valuemax="100" style="height: 30px;">
            <div id="progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" style="width: 0%">0%
            </div>
        </div>

        <div id="message-block" class="alert alert-light" role="status">Waiting for process to start...</div>

        <div class="mt-4">
            <button id="cancel-button" class="btn btn-danger" onclick="cancelProcess()">Cancel</button>
            <a id="back-button" class="btn btn-secondary" style="display: none;" th:href="@{${callback}}">Return</a>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>